---
layout: post
title: 《C++ Primer》第二章：变量和基本类型
categories: [C++, Book Notes]
description: C++ Primer 第二章
keywords: C++
mathjax: false
comment: true
---

* toc
{:toc}

## 基本内置类型

### 算数类型：

| 类型          | 含义           | 最小尺寸                       |
| ------------- | -------------- | ------------------------------ |
| `bool`        | 布尔类型       | 8bits                          |
| `char`        | 字符           | 8bits                          |
| `wchar_t`     | 宽字符         | 16bits                         |
| `char16_t`    | Unicode字符    | 16bits                         |
| `char32_t`    | Unicode字符    | 32bits                         |
| `short`       | 短整型         | 16bits                         |
| `int`         | 整型           | 16bits (在32位机器中是32bits)  |
| `long`        | 长整型         | 32bits                         |
| `long long`   | 长整型         | 64bits （是在C++11中新定义的） |
| `float`       | 单精度浮点数   | 6位有效数字                    |
| `double`      | 双精度浮点数   | 10位有效数字                   |
| `long double` | 扩展精度浮点数 | 10位有效数字                   |


### 如何选择类型

- 当明确知晓数值不可能是负数时，选用无符号类型
- 使用 `int` 执行整数运算。一般 `long` 的大小和 `int` 一样，而 `short` 常常显得太小。除非超过了 `int` 的范围，选择 `long long`
- 算术表达式中不要使用 `char` 或 `bool`
- 浮点运算选用 `double`

### 类型转换

- 布尔型赋给非布尔型，初始值为 false 结果为 0，初始值为 true 结果为 1
- 赋给无符号类型超出其表示范围的值时，该无符号类型变量初始值为对无符号类型表示数值总数取模后的余数
- 赋给有符号类型超出其表示范围的值时，其结果是未定义的

>- 尽量避免无法预知和依赖于实现环境的行为
>- 切勿混用带符号类型和无符号类型

### 字面值常量

- 一个形如 `42` 的值被称作**字面值常量** (literal)
  - 整型和浮点型字面值
  - 字符和字符串字面值
    - 字符字面值：单引号，`'a'`
    - 字符串字面值：双引号，`"Hello World"`
    - 编译器会自动在字符串结尾处添加一个空字符 `'\0'`
  - 转义序列。`\n`、`\t` 等
  - 布尔字面值。`true`，`false`
  - 指针字面值。`nullptr`

## 变量

**变量**提供一个**具名**的、可供程序操作的存储空间。

`C++` 中**变量**和**对象**一般可以互换使用

### 变量定义

- **定义形式**：类型说明符 (type specifier) + 一个或多个变量名组成的列表。如 `int sum = 0, value, units_sold = 0;`
- **初始化** (initialize)：对象在创建时获得了一个特定的值
  - **初始化不是赋值！**：
  - 初始化 = 创建变量 + 赋予初始值
  - 赋值 = 擦除对象的当前值 + 用新值代替
  - **列表初始化**：以下四种初始化方法等价
    ```cpp
    int units_sold = 0;
    int units_sold = {0};
    int units_sold{0};
    int units_sold(0);
    ```
  - 默认初始化：
    - 定义时没有指定初始值会被默认初始化
    - 在函数体内部的内置类型变量将不会被初始化
    - 每个类各自决定其初始化对象的方式
  - 建议初始化每一个内置类型的变量

### 变量的声明 (declaration) vs 定义 (define)

- 为了支持分离式编译，`C++` 将声明和定义区分开
  - **声明**使得名字为程序所知
  - **定义**负责创建与名字关联的实体
- 只声明而不定义： 在变量名前添加关键字 `extern`，如 `extern int i`，且不要显式初始化
- 任何包含了显式初始化的声明即成为定义，如 `extern double pi = 3.14`
- 变量只能被定义一次，但是可以多次声明

### 标识符
- 必须以字母或下划线开头
- 用户自定义标志符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头
- 定义在函数体外的标志符不能以下划线开头
- 大小写敏感

### 名字的作用域 (namescope)

名字的有效区域始于名字的声明语句，以声明语句所在的作用于末端为结束。

## 复合类型

### 引用

- **引用**：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如 `int &refVal = val;`
- 引用必须初始化
- 引用和它的初始值是**绑定 (bind)**在一起的，而**不是拷贝**
- 初始化完成后无法令引用重新绑定到另一个对象上
- 引用本身不是一个对象，因此不能定义引用的引用
- 引用只能绑定在对象上，而不能与字面值或者某个表达式的计算结果绑定在一起

### 指针

- 是一种"指向 (point to)"另外一种类型的复合类型
  > 与引用的主要区别：
  > - 指针本身就是一个对象，占据一定存储空间
  > - 在生命周期内指针可以指向不同的对象
  > - 指针定义时并非一定要赋初值
- **定义**指针类型： `int *ip1;`，**从右向左读**，`ip1` 是指向 `int` 类型的指针
- 指针存放某个对象的**地址**
- 获取对象的地址： `int i=42; int *p = &i`，`&` 是**取地址符**
- 指针的值的四种状态：
  - 指向一个对象
  - 指向紧邻对象的下一个位置
  - 空指针
  - 无效指针
- 指针访问对象： `cout << *p;`， `*` 是**解引用符**
- 通常情况下指针类型必须要与所指对象**严格匹配**；`void*` 指针可以存放**任意**对象的地址，但不能直接操作 `void*` 所指的对象
- **建议初始化所有指针**

> 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于理解其含义。离变量名最近的符号对变量的类型有最直接的影响，比如 `int *&r = p`，这里的 `r` 显然是一个引用

## const 限定符

### 初始化和 const
- 由于 const 对象创建后其值就**不能被改变**，因此 const 对象**必须初始化**
- const 变量默认仅在文件内有效，如果想在多个文件之间共享 const 对象，必须在变量定义前加 `extern`

### const 的引用

- **reference to const**（对常量的引用）：绑定到 const 对象的引用，通常也可简称为**常量引用**。如：
  ```cpp
  const int ival=1; 
  const int &refVal = ival;
  ```
  对常量的引用不能被用作修改它所绑定的对象。
- 初始化常量引用时允许用任意表达式作为初始值，包括非常量对象、字面值，甚至一般表达式
  ```cpp
  int i = 42;
  const int &r1 = i;        // 正确
  const int &r2 = 42;       // 正确
  const int &r3 = r1 * 2;   // 正确
  int &r4 = r1 * 2;         // 错误
  ```
- **常量引用仅对引用可参与的操作做出了限定**，对于引用的对象本身是不是常量则未作限定

### 指针和 const

- **pointer to const**（指向常量的指针）：不能用于改变其所指对象的值
  ```cpp
  const double pi = 3.14;
  const double *cptr = &pi;
  ```
  - 要想存放常量对象的地址，只能使用指向常量的指针
  - 指向常量的指针也可以指向一个非常量对象
- **const pointer**（指针常量）：指针本身是常量，如
  ```cpp
  int i = 0;
  int *const ptr = &i;
  ```

### 顶层 const

- **顶层 const**：指针本身是个常量
- **底层 const**：指针指向的对象是个常量。拷贝时要求拷入或拷出的对象具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换
  
> 用于声明引用的 const 都是顶层 const

> 更一般地，顶层 const 可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层 const 则与指针和引用等复合类型的基本类型部分有关。指针类型既可以是顶层 const 也可以是底层 const

### `constexpr` 和常量表达式

- 常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。
- `C++11` 新标准规定，允许将变量声明为 `constexpr` 类型以便由编译器来验证变量的值是否是一个常量的表达式

## 处理类型

### 类型别名

- 传统别名：使用 `typedef` 来定义类型的同义词。`typedef double wages;`
- 新标准别名：别名声明（alias declaration）：`using SI = Sales_item;` (C++11)

### auto 类型说明符

- **auto** 类型说明符：让编译器**自动推断类型**
- `int i = 0, &r = i; auto a = r;` 推断 `a` 的类型是 `int`
- 会忽略顶层const
- `const int ci = 1; const auto f = ci;` 推断类型是 `int`，需要自己加 `const`
- `C++11`

### decltype 类型指示符

- 从表达式的类型推断出要定义的变量的类型
- `decltype`：选择并返回操作数的**数据类型**
- `decltype(f()) sum = x;` 推断 `sum` 的类型是函数 `f` 的返回类型
- 不会忽略 `顶层const`

## 自定义数据结构

### struct

- 类可以以关键字 `struct` 开始，紧跟类名和类体
- 类数据成员：类体定义类的成员
- C++ 11：可以为类数据成员提供一个**类内初始值 (in-class initializer)**

### 编写自己的头文件

- 头文件通常包含哪些只能被定义一次的实体：类、`const` 和 `constexpr` 变量

预处理器概述：

- **预处理器 (preprocessor)**：确保头文件多次包含仍能安全工作
- 当预处理器看到 `#include` 标记时，会用指定的头文件内容代替 `#include`
- **头文件保护符 (header guard)**：头文件保护符依赖于预处理变量（如下例中的 `SALES_DATA_H`），可以有效防止重复包含头文件

```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H
strct Sale_data{
    ...
};
#endif
```
